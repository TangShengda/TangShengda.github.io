---
title: 实现一个深拷贝
date: 2020-05-26 18:25:59
tags:
---

# 一.JS如何有什么办法可以实现深拷贝？每个方法会有什么问题？

## 可以通过JSO.stringify和JSON.parse方法

这是JS实现深拷贝最简单的方法了，原理就是先将对象转换为字符串，再通过JSON.parse重新建立一个对象。 但是这种方法会存在属性丢失的问题

- **undefined、symbol 和函数这三种情况，会直接忽略，正则会被转换为空对象**
  
  ```tyoescript
    let obj = {
      a: '哈哈哈',
      b: function(){},
      c: () => {},
      d: Symbol('foo'),
      e: new RegExp('ab+c'),
      f: undefind
    }

    const newObj = JSON.parse(JSON.stringify(obj))

    console.log(newObj)
  ```

  运行结果:

  ![运行结果](https://fdfs.xmcdn.com/group79/M07/74/E6/wKgPC17M9dbCDB3EAABNoIa052U513.png)

  可以看到，函数、正则、Symbol，undefind都没有被正确的复制。

- **循环引用情况下，会报错**

  再看如下代码，如果在JSON.stringify中传入一个循环引用的对象，那么会直接报错：

  ```
  let objA = {
    name: 'this is a',
  }

  let objB = {
    name: 'this is b'
  }

  objA.child = objB
  objB.parent = objA

  console.log(JSON.parse(JSON.stringify(objA)))
  ```

  ![运行结果](https://fdfs.xmcdn.com/group80/M04/6C/FF/wKgPDF7NA7vQXSqPAAEsBhCgVfg210.jpg)

- **相同的引用会被重复复制**

  看如下代码
  ```
    let obj = { name: 'TSD' }

    let objA = { age: 18 }

    obj.age = objA
    obj.age2 = objA

    const newObj = JSON.parse(JSON.stringify(obj))

    obj.age.age = 22
    newObj.age.age = 30

    console.log('原对象', obj)

    console.log('新对象', newObj.age, newObj.age2)
  ```

  结果如下:

  ![运行结果](https://fdfs.xmcdn.com/group80/M02/6D/A2/wKgPDF7NBt6AIn1LAAB1dLRGuhg559.jpg)

  我们看到原对象改变age后，age2也得到了改变。但是复制对象没有保持和源对象一样的结构，所以JSON实现深拷贝不能处理指向相同引用的情况，相同的引用会被重复复制。


- **new Date 情况下，转换结果不正确**

  ```
    const date = new Date() 
    // Tue May 26 2020 20:44:32 GMT+0800 (中国标准时间)

    JSON.stringify(date) 
    // ""2020-05-26T12:44:32.869Z""

    JSON.parse(JSON.stringify(date)) 
    // "2020-05-26T12:44:32.869Z"
    
  ```

  解决方法是直接转换成时间戳

  ```
    const date = new Date().valueOf() // 1590497484613

    JSON.stringify(date) // "1590497484613"

    JSON.parse(JSON.stringify(date)) // 1590497484613
  ```

# 二.使用原生JS去实现一个深拷贝

##  深拷贝主要可以分为2步，浅拷贝与递归，浅拷贝时判断属性是否是对象，如果是对象，则进行递归

  第一步 先实现浅拷贝

  ```  
  const cloneDeep = (o) => {

    let target = {}

    for (const key in o) {
      if (Object.prototype.hasOwnProperty.call(o, key)) {
        console.log(key)
        target[key] = o[key]
      }
    }

    return target
  }
  ```

  第二步 加上是否是对象的判断并在相应的位置使用递归就可以实现简单深拷贝。

  ```
  const cloneDeep = (o) => {

    let target = {}

    for (const key in o) {
      if (Object.prototype.hasOwnProperty.call(o, key)) {
        if (isObject(o[key])) {
          target[key] = cloneDeep(o[key])
        } else {
          target[key] = o[key]
        }
      }
    }

    return target
  }

  // 判断是否是对象
  const isObject = (obj) => {
    return typeof obj === 'object'
  }
  ```
  到这里，一个简单的深拷贝已经完成了，下面要对各种特殊类型和循环引用进行处理

  第三步 循环应用处理

  其实解决办法很简单，我们设置一个数组或者哈希表存储已经拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出值返回即可

  ```

  ```
