---
title: 实现一个深拷贝
date: 2020-05-26 18:25:59
tags: 算法 深拷贝 JS JS基础 面试题 进阶
---

# 一.JS如何有什么办法可以实现深拷贝？每个方法会有什么问题？

## 可以通过JSO.stringify和JSON.parse方法

这是JS实现深拷贝最简单的方法了，原理就是先将对象转换为字符串，再通过JSON.parse重新建立一个对象。 但是这种方法会存在属性丢失的问题

- **undefined、symbol 和函数这三种情况，会直接忽略，正则会被转换为空对象**
  
  ```tyoescript
    let obj = {
      a: '哈哈哈',
      b: function(){},
      c: () => {},
      d: Symbol('foo'),
      e: new RegExp('ab+c'),
      f: undefind
    }

    const newObj = JSON.parse(JSON.stringify(obj))

    console.log(newObj)
  ```

  运行结果:

  ![运行结果](https://fdfs.xmcdn.com/group79/M07/74/E6/wKgPC17M9dbCDB3EAABNoIa052U513.png)

  可以看到，函数、正则、Symbol，undefind都没有被正确的复制。

- **循环引用情况下，会报错**

  再看如下代码，如果在JSON.stringify中传入一个循环引用的对象，那么会直接报错：

  ```
  let objA = {
    name: 'this is a',
  }

  let objB = {
    name: 'this is b'
  }

  objA.child = objB
  objB.parent = objA

  console.log(JSON.parse(JSON.stringify(objA)))
  ```

  ![运行结果](https://fdfs.xmcdn.com/group80/M04/6C/FF/wKgPDF7NA7vQXSqPAAEsBhCgVfg210.jpg)

- **相同的引用会被重复复制**

  看如下代码
  ```
    let obj = { name: 'TSD' }

    let objA = { age: 18 }

    obj.age = objA
    obj.age2 = objA

    const newObj = JSON.parse(JSON.stringify(obj))

    obj.age.age = 22
    newObj.age.age = 30

    console.log('原对象', obj)

    console.log('新对象', newObj.age, newObj.age2)
  ```

  结果如下:

  ![运行结果](https://fdfs.xmcdn.com/group80/M02/6D/A2/wKgPDF7NBt6AIn1LAAB1dLRGuhg559.jpg)

  我们看到原对象改变age后，age2也得到了改变。但是复制对象没有保持和源对象一样的结构，所以JSON实现深拷贝不能处理指向相同引用的情况，相同的引用会被重复复制。


- **new Date 情况下，转换结果不正确**

  ```
    const date = new Date() 
    // Tue May 26 2020 20:44:32 GMT+0800 (中国标准时间)

    JSON.stringify(date) 
    // ""2020-05-26T12:44:32.869Z""

    JSON.parse(JSON.stringify(date)) 
    // "2020-05-26T12:44:32.869Z"
    
  ```

  解决方法是直接转换成时间戳

  ```
    const date = new Date().valueOf() // 1590497484613

    JSON.stringify(date) // "1590497484613"

    JSON.parse(JSON.stringify(date)) // 1590497484613
  ```

# 二.使用原生JS去实现一个深拷贝

##  深拷贝主要可以分为2步，浅拷贝与递归，浅拷贝时判断属性是否是对象，如果是对象，则进行递归

  **第一步 先实现浅拷贝**

  ```  
  const cloneDeep = (o) => {

    let target = {}

    for (const key in o) {
      if (Object.prototype.hasOwnProperty.call(o, key)) {
        console.log(key)
        target[key] = o[key]
      }
    }

    return target
  }
  ```

  **第二步 加上是否是对象的判断并在相应的位置使用递归就可以实现简单深拷贝**

  ```
  const cloneDeep = (o) => {

    let target = {}

    for (const key in o) {
      if (Object.prototype.hasOwnProperty.call(o, key)) {
        if (isObject(o[key])) {
          target[key] = cloneDeep(o[key])
        } else {
          target[key] = o[key]
        }
      }
    }

    return target
  }

  // 判断是否是对象
  const isObject = (obj) => {
    return typeof obj === 'object'
  }
  ```
  到这里，一个简单的深拷贝已经完成了，但是依然存在很多问题

  - 没有对传入参数进行校验，传入 null 时应该返回 null 而不是 {}
  - 对于对象的判断逻辑不严谨，因为 typeof null === 'object'
  - 没有考虑数组的兼容
  
  
**第三步 拷贝数组**
  
  ```
    const cloneDeep = (o, hash = new WeakMap()) => {
      if (!isObject(o)) return o

      const target = Array.isArray(o) ? [] : {} // 新增代码

      for (const key in o) {
        if (Object.prototype.hasOwnProperty.call(o, key)) {
          if (isObject(o[key])) {
            target[key] = cloneDeep(o[key])
          } else {
            target[key] = o[key]
          }
        }
      }

      return target
    }

    // 判断是否是对象
    const isObject = (obj) => {
      return typeof obj === 'object' && obj !== null
    }

  ```

  **第四步 循环应用处理**

  其实解决办法很简单，我们设置一个数组或者哈希表存储已经拷贝过的对象，当检测到当前对象已存在于哈希表中时，取出值返回即可，顺便还解决了引用丢失的问题

  ```
    const cloneDeep = (o, hash = new WeakMap()) => {

      if (!isObject(o)) return o
      if (hash.has(o)) return hash.get(o) // 新增代码

      const target = Array.isArray(o) ? [] : {}


      hash.set(o, target) // 新增代码

      for (const key in o) {
        if (Object.prototype.hasOwnProperty.call(o, key)) {
          if (isObject(o[key])) {
            target[key] = cloneDeep(o[key], hash) // 新增代码
          } else {
            target[key] = o[key]
          }
        }
      }

      return target
    }

    // 判断是否是对象
    const isObject = (obj) => {
      return typeof obj === 'object' && obj !== null
    }
  ```

  使用数组
  ```
    const cloneDeep = (o, uniqueList = []) => {
      if (!isObject(o)) return o

      const target = Array.isArray(o) ? [] : {}

      const uniqueData = find(uniqueList, o)
      if (uniqueData) {
        return uniqueData.target
      }
      uniqueList.push({
        source: o,
        target
      })

      for (const key in o) {
        if (Object.prototype.hasOwnProperty.call(o, key)) {
          if (isObject(o[key])) {
            target[key] = cloneDeep(o[key],uniqueList)  // 新增代码
            console.log(target)
          } else {
            target[key] = o[key]
          }
        }
      }

      return target
    }

    const find = (arr, source) => {
      for (const item of arr) {
        if (item.source === source) return item
      }
    }

    // 判断是否是对象
    const isObject = (obj) => {
      return typeof obj === 'object' && obj !== null
    }
  ```

  **第五步 拷贝Symbol**

  我们可以Symbol类型吗？当然可以。Symbol是ES6才有的类型，我们需要一些方法来检测Symbol类型

  - 方法一：Object.getOwnPropertySymbols(...)
  - 方法二：Reflect.ownKeys(...)


  方法一思路是，先查找一下有没有Symbol属性，如果查找到则先遍历处理 Symbol 情况，然后再处理正常情况，多出来的逻辑就是下面的新增代码。

  ```
    const cloneDeep = (o, hash = new WeakMap()) => {

    if (!isObject(o)) return o
    if (hash.has(o)) return hash.get(o)

    const target = Array.isArray(o) ? [] : {}

    hash.set(o, target)

    // 新增代码
    let symbolKeys = Object.getOwnPropertySymbols(o)
    if (symbolKeys.length >= 0) {
      symbolKeys.forEach((symbolKey, index) => {
        if (isObject(o[symbolKey])) {
          target[symbolKey] = cloneDeep(o[symbolKey], hash)
        } else {
          target[symbolKey] = o[symbolKey]
        }
      })
    }

    for (const key in o) {
      if (Object.prototype.hasOwnProperty.call(o, key)) {
        if (isObject(o[key])) {
          target[key] = cloneDeep(o[key], hash)
        } else {
          target[key] = o[key]
        }
      }
    }

    return target
  }

  // 判断是否是对象
  const isObject = (obj) => {
    return typeof obj === 'object' && obj !== null
  }
  ```

  方法二: 这里使用了 Reflect.ownKeys() 获取所有的键值，同时包括 Symbol，对 source 遍历赋值即可。
  ```
    const cloneDeep = (o, hash = new WeakMap()) => {
      if (!isObject(o)) return o
      if (hash.has(o)) return hash.get(o)

      const target = Array.isArray(o) ? [] : {}

      hash.set(o, target)

      Reflect.ownKeys(o).forEach((key) => {
        if (isObject(o[key])) {
          target[key] = cloneDeep(o[key])
        } else {
          target[key] = o[key]
        }
      })

      return target
    }

    // 判断是否是对象
    const isObject = (obj) => {
      return typeof obj === 'object' && obj !== null
    }
  ```

  Reflect.ownKeys() 这种方式的问题在于不能深拷贝原型链上的数据，因为返回的是目标对象自身的属性键组成的数组。如果想深拷贝原型链上的数据怎么办，那用 for..in 就可以了。

  **第五步 破解递归爆栈**

  上面使用的都是递归方法，但是有一个问题在于会爆栈，错误提示如下。

  ```
    // RangeError: Maximum call stack size exceeded
  ```

  其实使用循环就可以了，有的面试官可能会问，实现一个不用递归版本的深克隆

  ```
      const cloneDeep = (o) => {
      const root = {}

      // 栈
      const loopList = [{
        parent: root,
        key: undefined,
        data: o
      }]

      while (loopList.length) {
        const node = loopList.pop()
        const { parent, key, data } = node

        let res = parent
        if (typeof key !== 'undefined') {
          parent[key] = {}
          res = parent[key]
        }

        for (const k in data) {
          if (data.hasOwnProperty(k)) {
            if (isObject(data[k])) {
              loopList.push({
                parent: res,
                key: k,
                data: data[k]
              })
            } else {
              res[k] = data[k]
            }
          }
        }
      }

      return root

    }
  ```







